use super::util::replace::store_collection;
use super::{Context, Generator};
use crate::path::{assets_dir, crate_src_dir};
use crate::plugin::Plugin;
use anyhow::Result;
use colored::Colorize;
use convert_case::Case;
use std::path::{Path, PathBuf};
use std::time::Instant;

pub(super) fn generate() -> Result<()> {
  let start = Instant::now();
  println!("{}", "generating crate code".cyan());

  let assets = assets_plugin_rs_dir();
  generate_plugin(&assets)?;
  generate_manager(&assets)?;
  generate_commands(&assets)?;
  generate_lib(&assets)?;

  let duration = start.elapsed();
  println!("{}", format!("done in {duration:?}").green());

  Ok(())
}

fn generate_plugin(assets: &Path) -> Result<()> {
  let input = assets.join("plugin.rs");
  let output = |ctx: Context<'_>| {
    let dir = crate_src_dir(ctx.plugin);
    dir.join(format!("{}.rs", ctx.name)).into()
  };

  Generator::builder(&input, &output)
    .skip(&[Plugin::Store])
    .replace(&[("__PASCAL_PLUGIN_TITLE__", &|it| it.title_as(Case::Pascal))])
    .generate()
}

fn generate_manager(assets: &Path) -> Result<()> {
  let input = assets.join("manager.rs");
  let output = |ctx: Context<'_>| {
    let dir = crate_src_dir(ctx.plugin);
    dir.join("manager.rs").into()
  };

  Generator::builder(&input, &output)
    .skip(&[Plugin::Store])
    .replace(&[
      ("__PASCAL_PLUGIN_TITLE__", &|it| it.title_as(Case::Pascal)),
      ("__SNAKE_PLUGIN_TITLE__", &|it| it.title_as(Case::Snake)),
    ])
    .generate()
}

fn generate_commands(assets: &Path) -> Result<()> {
  let input = assets.join("commands.rs");
  let output = |ctx: Context<'_>| {
    let dir = crate_commands_dir(ctx.plugin);
    dir.join("autogenerated.rs").into()
  };

  let import_source = |plugin| {
    if let Plugin::Store = plugin {
      String::from("crate")
    } else {
      String::from("tauri_store")
    }
  };

  Generator::builder(&input, &output)
    .replace(&[
      ("__IMPORT_SOURCE__", &import_source),
      ("__STORE_COLLECTION__", &|it| {
        store_collection(it, Case::Snake)
      }),
    ])
    .generate()
}

fn generate_lib(assets: &Path) -> Result<()> {
  let input = assets.join("lib.rs");
  let output = |ctx: Context<'_>| {
    let dir = crate_src_dir(ctx.plugin);
    dir.join("lib.rs").into()
  };

  Generator::builder(&input, &output)
    .skip(&[Plugin::Store])
    .replace(&[
      ("__PASCAL_PLUGIN_TITLE__", &|it| it.title_as(Case::Pascal)),
      ("__SNAKE_PLUGIN_TITLE__", &|it| it.title_as(Case::Snake)),
      ("__REGISTERED_PLUGIN_NAME__", &|it| it.title_as(Case::Snake)),
    ])
    .generate()
}

fn assets_plugin_rs_dir() -> PathBuf {
  assets_dir().join("plugin-rs")
}

fn crate_commands_dir(plugin: Plugin) -> PathBuf {
  crate_src_dir(plugin).join("command")
}
