use super::{prepend_autogenerated, read_asset, write_file, PASCAL_PLUGIN_NAME, PLUGIN_NAME};
use crate::path::{assets_dir, crate_commands_dir, crate_src_dir};
use crate::target::Target;
use anyhow::Result;
use colored::Colorize;
use convert_case::{Case, Casing};
use std::path::Path;
use std::time::Instant;
use strum::VariantArray;

pub(super) fn generate() -> Result<()> {
  let start = Instant::now();
  println!("{}", "generating crate code".cyan());

  let assets_dir = assets_dir();
  generate_plugin(&assets_dir)?;
  generate_manager(&assets_dir)?;
  generate_commands(&assets_dir)?;
  generate_lib(&assets_dir)?;

  let duration = start.elapsed();
  println!("{}", format!("done in {duration:?}").green());

  Ok(())
}

fn generate_plugin(assets_dir: &Path) -> Result<()> {
  let plugin_rs = assets_dir.join("plugin.rs");
  let mut contents = read_asset(&plugin_rs)?;
  prepend_autogenerated(&mut contents);

  for krate in Target::VARIANTS {
    let Some(plugin_name) = krate.plugin_name() else {
      continue;
    };

    let dir = crate_src_dir(*krate);
    let plugin = dir.join(format!("{plugin_name}.rs"));
    let contents = contents
      .replace(PASCAL_PLUGIN_NAME, &plugin_name.to_case(Case::Pascal))
      .replace(PLUGIN_NAME, plugin_name);

    write_file(&plugin, &contents)?;
  }

  Ok(())
}

fn generate_manager(assets_dir: &Path) -> Result<()> {
  let manager_rs = assets_dir.join("manager.rs");
  let mut contents = read_asset(&manager_rs)?;
  prepend_autogenerated(&mut contents);

  for krate in Target::VARIANTS {
    let Some(plugin_name) = krate.plugin_name() else {
      continue;
    };

    let dir = crate_src_dir(*krate);
    let manager = dir.join("manager.rs");
    let contents = contents
      .replace(PASCAL_PLUGIN_NAME, &plugin_name.to_case(Case::Pascal))
      .replace(PLUGIN_NAME, plugin_name);

    write_file(&manager, &contents)?;
  }

  Ok(())
}

fn generate_commands(assets_dir: &Path) -> Result<()> {
  let commands_rs = assets_dir.join("commands.rs");
  let mut contents = read_asset(&commands_rs)?;
  prepend_autogenerated(&mut contents);

  for krate in Target::VARIANTS {
    let Some(plugin_name) = krate.plugin_name() else {
      continue;
    };

    let dir = crate_commands_dir(*krate);
    let autogenerated = dir.join("autogenerated.rs");
    let contents = contents.replace(PLUGIN_NAME, plugin_name);
    write_file(&autogenerated, &contents)?;
  }

  Ok(())
}

fn generate_lib(assets_dir: &Path) -> Result<()> {
  let lib_rs = assets_dir.join("lib.rs");
  let mut contents = read_asset(&lib_rs)?;
  prepend_autogenerated(&mut contents);

  for krate in Target::VARIANTS {
    let Some(plugin_name) = krate.plugin_name() else {
      continue;
    };

    let contents = contents
      .replace(PASCAL_PLUGIN_NAME, &plugin_name.to_case(Case::Pascal))
      .replace(PLUGIN_NAME, plugin_name);

    write_file(&crate_src_dir(*krate).join("lib.rs"), &contents)?;
  }

  Ok(())
}
