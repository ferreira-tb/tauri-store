mod crates;
mod examples;
mod packages;
mod permissions;

use crate::fs::{read_file, write_file};
use crate::target::Target;
use crate::transform::prepend_autogenerated;
use anyhow::Result;
use bon::Builder;
use clap::Args;
use convert_case::{Case, Casing};
use std::path::{Path, PathBuf};
use strum::VariantArray;

const PLUGIN_NAME: &str = "PLUGIN_NAME";
const PASCAL_PLUGIN_NAME: &str = "PASCAL_PLUGIN_NAME";
const KEBAB_PLUGIN_FULL_NAME: &str = "KEBAB_PLUGIN_FULL_NAME";

#[derive(Debug, Args)]
pub struct Codegen {
  #[arg(long)]
  cleanup: bool,
}

impl Codegen {
  pub fn run(&self) -> Result<()> {
    crates::generate()?;
    packages::generate()?;
    examples::generate()?;
    permissions::generate(self)?;

    Ok(())
  }
}

#[derive(Builder)]
struct Generator<'a> {
  #[builder(start_fn)]
  input: &'a Path,
  #[builder(start_fn)]
  output: &'a dyn Fn(OutputContext) -> PathBuf,
  #[builder(default = &[&prepend_autogenerated])]
  transform: &'a [&'a dyn Fn(&mut String)],
}

impl Generator<'_> {
  pub fn generate(self) -> Result<()> {
    let mut contents = read_file(self.input)?;
    self
      .transform
      .iter()
      .for_each(|t| t(&mut contents));

    for target in Target::VARIANTS {
      let Some(name) = target.plugin_name() else {
        continue;
      };

      let contents = contents
        .replace(PASCAL_PLUGIN_NAME, &name.to_case(Case::Pascal))
        .replace(KEBAB_PLUGIN_FULL_NAME, target.as_ref())
        .replace(PLUGIN_NAME, name);

      let ctx = OutputContext::new(*target, name);
      write_file(&(self.output)(ctx), &contents)?;
    }

    Ok(())
  }
}

struct OutputContext<'a> {
  target: Target,
  name: &'a str,
}

impl<'a> OutputContext<'a> {
  fn new(target: Target, name: &'a str) -> Self {
    Self { target, name }
  }
}
