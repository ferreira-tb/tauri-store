mod example;
mod krate;
mod package;

use crate::target::Target;
use anyhow::{Context, Result};
use bon::Builder;
use clap::Args;
use colored::Colorize;
use convert_case::{Case, Casing};
use std::fs;
use std::path::{Path, PathBuf};
use strum::VariantArray;
use transform::prepend_autogenerated;

const PLUGIN_NAME: &str = "PLUGIN_NAME";
const PASCAL_PLUGIN_NAME: &str = "PASCAL_PLUGIN_NAME";
const KEBAB_PLUGIN_FULL_NAME: &str = "KEBAB_PLUGIN_FULL_NAME";

#[derive(Debug, Args)]
pub struct Codegen;

impl Codegen {
  #[expect(clippy::unused_self)]
  pub fn run(&self) -> Result<()> {
    krate::generate()?;
    package::generate()?;
    example::generate()?;

    Ok(())
  }
}

#[derive(Builder)]
struct Generator<'a> {
  #[builder(start_fn)]
  input: &'a Path,
  #[builder(start_fn)]
  output: &'a dyn Fn(OutputContext) -> PathBuf,
  #[builder(default = &[&prepend_autogenerated])]
  transform: &'a [&'a dyn Fn(&mut String)],
}

impl<'a> Generator<'a> {
  pub fn generate(self) -> Result<()> {
    let mut contents = read_asset(self.input)?;
    self
      .transform
      .iter()
      .for_each(|t| t(&mut contents));

    for target in Target::VARIANTS {
      let Some(name) = target.plugin_name() else {
        continue;
      };

      let contents = contents
        .replace(PASCAL_PLUGIN_NAME, &name.to_case(Case::Pascal))
        .replace(KEBAB_PLUGIN_FULL_NAME, target.as_ref())
        .replace(PLUGIN_NAME, name);

      let ctx = OutputContext::new(*target, name);
      write_file(&(self.output)(ctx), &contents)?;
    }

    Ok(())
  }
}

struct OutputContext<'a> {
  target: Target,
  name: &'a str,
}

impl<'a> OutputContext<'a> {
  fn new(target: Target, name: &'a str) -> Self {
    Self { target, name }
  }
}

fn read_asset(path: &Path) -> Result<String> {
  fs::read_to_string(path)
    .with_context(|| format!("failed to read asset: {}", path.display()).bright_red())
    .map_err(Into::into)
}

fn write_file(path: &Path, contents: &str) -> Result<()> {
  let display = path.display();
  fs::write(path, contents)
    .with_context(|| format!("failed to write file: {display}").bright_red())
    .inspect(|()| {
      let message = format!("generated: {display}");
      println!("{}", message.truecolor(105, 105, 105));
    })
    .map_err(Into::into)
}

mod transform {
  const AUTOGENERATED_WARNING: &str = "
// This file was autogenerated and should not be edited manually.
// Check the `codegen` command in the `tauri-store-cli` crate.\n
";

  pub(super) fn prepend_autogenerated(contents: &mut String) {
    let warning = AUTOGENERATED_WARNING.trim_start();
    contents.insert_str(0, warning);
  }

  pub(super) fn remove_nocheck(contents: &mut String) {
    contents
      .replace("// @ts-nocheck", "")
      .trim_start()
      .clone_into(contents);
  }
}
